# BMSTU EXAM по Алгоритмическим языкам (3 семестр)
## Теория(вопросы):
### Вопрос №1 (Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list.)
* Определение.
> Двунаправленный (двусвязный) список – это структура данных, состоящая из последовательности элементов, каждый из которых содержит информационную часть и два указателя на соседние элементы.
* Узел двусвязного списка можно представить в виде:
```bash
Struct list{
  int data; // Поле данных
  struct list *next; // Указатель на следующий элемент
  struct list *prev; // Указатель на предыдущий элемент
};
```
* Поиск элемента по значению(Сложность поиска О(n),где n-количество узлов в списке).
```bash
std::find(list.begin(),list.end(),value);
```
* Вставка элемента в список.

1 способ.
```bash
list * addElem(list *lst, int num){
  list *tmp,*p;
  tmp = new struct list * (sizeod(list());
  p = lst ->next;
  lst->next = tmp;
  tmp->data=num;
  tmp->prev=lst;
  if(p!=nullptr)
      p->prev=tmp;
  return tmp;
  }
```
2 способ(при создании).
```bash
list<int> lst = {1,2,3,4,5}; 
```
3 способ(добавление в любую часть контейнера).
```bash
string cpp = "It is easy!";
insert(it,cpp); // it - местоположение(итератор), cpp - значение новой ячейки.
```
* Удаление элемента.
```bash
list<int>a;
a.push_back(1);
a.push_back(2);
a.push_back(3); //1 2 3
a.pop_front(); // 2 3
a.pop_back(); // 2
a.pop_back(); // -
```
* Реализация функции удаления элемента из двусвязного списка.
```bash
list delElem(list *lst){
  list *prev,*next;
  prev = lst -> prev;
  next = lst -> next;
  if(prev!=nullptr) pev->next = lst->next;
  if(next!=nullptr) next->prev = lst->prev;
  delete lst;
  return prev;
}
```
* Основные методы std::list
> clear(полное очищение)
insert(вставка по итератору)
erase(Принимает один или два итератора и удаляет элемент или элементы в диапазоне
push_back(засунуть элемент в конец)
pop_back(вытащить элемент из конца)
push_front(засунуть элемент в начало)
pop_front(вытащить элемент из начала)
swap()
size(размер контейнера, работает за О(N)).
* Пример работы с std::list
```bash
list<int> a;
    a.push_back(60);
    a.push_front(29);
    a.push_back(78);
    a.push_front(47);
    for_each(
        a.begin(), 
        a.end(), 
        [](int k){ cout << k<< endl;} // это лямбда-функция
    );
    // 47 29 60 78
```
### Вопрос №2 (Класс std::map.Внутренняя реализация map,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::map)
* Определение.
> Map - это асоциативный контейнер, который работает по принципу КЛЮЧ-ЗНАЧЕНИЕ. То есть map - это красно-чёрное (сбалансированное) дерево, в котором пары хранятся и сравниваются по первому элементу.
Ключ может быть любой - int, string, pair
```bash
mp[0] = 1; // Ключ - число
mp["Hi"] = 5; // Ключ - string
pair<int,int> p = make_pair(1,7);
mp3[p] = 4; // Ключ - пара чисел
```
* Сложность операций.
  [] Поиск
  [] Удалени, добавление
  Происходят за log(N), N - размер контейнера.
  [] Cортировка происходит при построении.
* Реализация map.
```bash
#include<map>
map<<L>,<R>> [имя]; // L-тип данных ключа, R - тип данных значения
```
Добавление значения при инициализации(C++ и выше).
```bash
map<string,string> book ={
{"Hi","Привет"},
{"!","!"},
{"No","Нет"}};
///
cout << book["Hi"];
cout << book["No"];
```
* Основные методы std::map
> insert, erase, count, find

Insert - вставка нового элемента.
```bash
// 1 Variant
mp.insert(make_pair(num_1, num_2));
// 2 Variant(without insert)
mp[num_1] = num_2;
```
Count - возвращение количества элементов с данным ключом.
```bash
// Либо 0 или 1
mp[0] = 1;
mp[5] = 5;
mp["Fuck"] = 5;
...
mp.count(0); // 1
mp.count(8); // 0
mp.count("Fuck"); // 1
```
Find - поиск определенного ключа в контейнере.
  [] Если он есть, то (it) на его местоположение
  [] Если его нет, то (it) на конец контейнера
```bash
map<string,string> book;
book["book"] = "Книга";
map<string,string>::iterator it, it_2;
it = book.finf("book");
cout << it ->second << endl;
it_2 = book.find("books");
if(it_2==book.end()){
    cout << "Error";
}
```
Erase - для удаления элементов
```bash
map <<l>,<r>>::iterator [name];
[name] = <mp>.find("");
<mp>.erase([name]);
```
* Пример работы с std::map
```bash
map<string,string> book ={
{"Hi","Привет"},
{"!","!"},
{"No","Нет"}};
...
cout << book["Hi"];
cout << book["No"];
```
### Вопрос №3 (Класс std::set.Внутренняя реализация map,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::set)
* Определение
> Set - это контейнер, который автоматически сортирует добавленнные элементы в контейнер в порядке возрастания, при чем если имеются повторяющиеся элементы, то будет сохранен только 1 экземпляр."Плюсы" set: быстрая сортировка, "Минусы" set: нельзя обратиться к конкретной ячейке по индексу. В таких случаях лучше std::vector
```bash
Схема добавления элементво в SET
1112323 -> 123
12321 -> 123
12334656 -> 123456
```
* Описание конструкции.
```bash
#include<set>
set<[тип данных]> <name>;
set<int> st;
```
* Cложности операций
>Поиск: O(log(N)),
>Удаление: O(log(N)) (Может понадобиться перестроить дерево),
>Добавление: O(log(N))
>Сортировка: Сортируется при построении.

[] Insert - добавить новый элемент в контейнер(Сложность log(N), N - размер контейнера).
```bash
st.insert(<Значение>);
```
[] Greater - изменить строку в обратную сторону при сортировке.
```bash
set<[тип], greater[тип]> [name];
set<long long> greater <long long> st;
```
[] C++ и выше.
```bash
set<int> st{1,2,3,4,5,1};
```
* Итераторы.
```bash
set<int> st{1,2,3};
st<int>::iterator it = st.begin();
cout << *it; // 1
it++
cout << *it; // 1 2
```
* Методы для std::set
> copy
> erase
> find
> count
> lower_bound
> upper_bound

[] Copy - вывод элементов контейнера
```bash
copy([начало],[конец], ostream_iterator<[тип]>(cout,[отступ]));
```

[] Erase - удаление
[] Lower_bound - проверяет есть ли такой же или больше в виде элемента   #>=key
```bash
set<int> st{1,5,9,11};
st.lower_bound(1); // 1
st.lower_bound(6); // 9
st.lower_bound(11); // 11
```
[] Upper_bound - #>key
```bash
set<int> st{1,3,10};
st.upper_bound(4); // 10
```
* Пример работы с std::set
```bash
// Выше полно примеров
```

### Вопрос №4 (Класс std::unordered_map.Внутренняя реализация unordered_map,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::unordered_map)


