# BMSTU EXAM по Алгоритмическим языкам (3 семестр)
## Теория(вопросы):
### Вопрос №1 (Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list.)
* Определение.
> Двунаправленный (двусвязный) список – это структура данных, состоящая из последовательности элементов, каждый из которых содержит информационную часть и два указателя на соседние элементы.
* Узел двусвязного списка можно представить в виде:
```bash
Struct list{
  int data; // Поле данных
  struct list *next; // Указатель на следующий элемент
  struct list *prev; // Указатель на предыдущий элемент
};
```
* Поиск элемента по значению(Сложность поиска О(n),где n-количество узлов в списке).
```bash
std::find(list.begin(),list.end(),value);
```
* Вставка элемента в список.

1 способ.
```bash
list * addElem(list *lst, int num){
  list *tmp,*p;
  tmp = new struct list * (sizeod(list());
  p = lst ->next;
  lst->next = tmp;
  tmp->data=num;
  tmp->prev=lst;
  if(p!=nullptr)
      p->prev=tmp;
  return tmp;
  }
```
2 способ(при создании).
```bash
list<int> lst = {1,2,3,4,5}; 
```
3 способ(добавление в любую часть контейнера).
```bash
string cpp = "It is easy!";
insert(it,cpp); // it - местоположение(итератор), cpp - значение новой ячейки.
```
* Удаление элемента.
```bash
list<int>a;
a.push_back(1);
a.push_back(2);
a.push_back(3); //1 2 3
a.pop_front(); // 2 3
a.pop_back(); // 2
a.pop_back(); // -
```
* Реализация функции удаления элемента из двусвязного списка.
```bash
list delElem(list *lst){
  list *prev,*next;
  prev = lst -> prev;
  next = lst -> next;
  if(prev!=nullptr) pev->next = lst->next;
  if(next!=nullptr) next->prev = lst->prev;
  delete lst;
  return prev;
}
```
* Основные методы std::list
> clear(полное очищение)
insert(вставка по итератору)
erase(Принимает один или два итератора и удаляет элемент или элементы в диапазоне
push_back(засунуть элемент в конец)
pop_back(вытащить элемент из конца)
push_front(засунуть элемент в начало)
pop_front(вытащить элемент из начала)
swap()
size(размер контейнера, работает за О(N)).
* Пример работы с std::list
```bash
list<int> a;
    a.push_back(60);
    a.push_front(29);
    a.push_back(78);
    a.push_front(47);
    for_each(
        a.begin(), 
        a.end(), 
        [](int k){ cout << k<< endl;} // это лямбда-функция
    );
    // 47 29 60 78
```
### Вопрос №2 (Класс std::map.Внутренняя реализация map,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::map)
* Определение.
> Map - это асоциативный контейнер, который работает по принципу КЛЮЧ-ЗНАЧЕНИЕ. То есть map - это красно-чёрное (сбалансированное) дерево, в котором пары хранятся и сравниваются по первому элементу.
Ключ может быть любой - int, string, pair
```bash
mp[0] = 1; // Ключ - число
mp["Hi"] = 5; // Ключ - string
pair<int,int> p = make_pair(1,7);
mp3[p] = 4; // Ключ - пара чисел
```
* Сложность операций.
  [] Поиск
  [] Удалени, добавление
  Происходят за log(N), N - размер контейнера.
  [] Cортировка происходит при построении.
* Реализация map.
```bash
#include<map>
map<<L>,<R>> [имя]; // L-тип данных ключа, R - тип данных значения
```
Добавление значения при инициализации(C++ и выше).
```bash
map<string,string> book ={
{"Hi","Привет"},
{"!","!"},
{"No","Нет"}};
///
cout << book["Hi"];
cout << book["No"];
```
* Основные методы std::map
> insert, erase, count, find

Insert - вставка нового элемента.
```bash
// 1 Variant
mp.insert(make_pair(num_1, num_2));
// 2 Variant(without insert)
mp[num_1] = num_2;
```
Count - возвращение количества элементов с данным ключом.
```bash
// Либо 0 или 1
mp[0] = 1;
mp[5] = 5;
mp["Fuck"] = 5;
...
mp.count(0); // 1
mp.count(8); // 0
mp.count("Fuck"); // 1
```
Find - поиск определенного ключа в контейнере.
  [] Если он есть, то (it) на его местоположение
  [] Если его нет, то (it) на конец контейнера
```bash
map<string,string> book;
book["book"] = "Книга";
map<string,string>::iterator it, it_2;
it = book.finf("book");
cout << it ->second << endl;
it_2 = book.find("books");
if(it_2==book.end()){
    cout << "Error";
}
```
Erase - для удаления элементов
```bash
map <<l>,<r>>::iterator [name];
[name] = <mp>.find("");
<mp>.erase([name]);
```
* Пример работы с std::map
```bash
map<string,string> book ={
{"Hi","Привет"},
{"!","!"},
{"No","Нет"}};
...
cout << book["Hi"];
cout << book["No"];
```
### Вопрос №3 (Класс std::set.Внутренняя реализация map,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::set)
* Определение
> Set - это контейнер, который автоматически сортирует добавленнные элементы в контейнер в порядке возрастания, при чем если имеются повторяющиеся элементы, то будет сохранен только 1 экземпляр."Плюсы" set: быстрая сортировка, "Минусы" set: нельзя обратиться к конкретной ячейке по индексу. В таких случаях лучше std::vector
```bash
Схема добавления элементво в SET
1112323 -> 123
12321 -> 123
12334656 -> 123456
```
* Описание конструкции.
```bash
#include<set>
set<[тип данных]> <name>;
set<int> st;
```
* Cложности операций
>Поиск: O(log(N)),
>Удаление: O(log(N)) (Может понадобиться перестроить дерево),
>Добавление: O(log(N))
>Сортировка: Сортируется при построении.

[] Insert - добавить новый элемент в контейнер(Сложность log(N), N - размер контейнера).
```bash
st.insert(<Значение>);
```
[] Greater - изменить строку в обратную сторону при сортировке.
```bash
set<[тип], greater[тип]> [name];
set<long long> greater <long long> st;
```
[] C++ и выше.
```bash
set<int> st{1,2,3,4,5,1};
```
* Итераторы.
```bash
set<int> st{1,2,3};
st<int>::iterator it = st.begin();
cout << *it; // 1
it++
cout << *it; // 1 2
```
* Методы для std::set
> copy
> erase
> find
> count
> lower_bound
> upper_bound

[] Copy - вывод элементов контейнера
```bash
copy([начало],[конец], ostream_iterator<[тип]>(cout,[отступ]));
```

[] Erase - удаление
[] Lower_bound - проверяет есть ли такой же или больше в виде элемента   #>=key
```bash
set<int> st{1,5,9,11};
st.lower_bound(1); // 1
st.lower_bound(6); // 9
st.lower_bound(11); // 11
```
[] Upper_bound - #>key
```bash
set<int> st{1,3,10};
st.upper_bound(4); // 10
```
* Пример работы с std::set
```bash
// Выше полно примеров
```

### Вопрос №4 (Класс std::unordered_map.Внутренняя реализация unordered_map,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::unordered_map)

> Unordered_map - аналог map (то есть контейнер для пар элементов, главным из которых является первый).
* Основные методы.
> Как у std::map

* Сложности операций в std::unordered_map
> Поиск: O(1), 
  Удаление: O(1), 
  Добавление: O(1), 
  Сортировка: по определению несортируемый.
  Для сортировки сначала придётся куда-то переложить всё содержимое - например, в vector.
* Пример работы с std::unordered_map
```bash
std::unordered_map<int,std::string> dict={{1,"one"},{2,"two"}};

dict.insert({3,"three"}); // ok
dict.insert(std::make_pair{4,"four"}); // ok
dict.insert({4,"another four"}, {5,"five"}); // Вставиться только five
```
### Вопрос №5 (Класс std::vector.Внутренняя реализация vector,его основные методы. Сложность поиска, сортировки,удаления элемента, добавления элемента. Пример работы с std::vector.Особенности std::vector<bool>)
* Определение
> Vector - это последовательный массив, инкапсулирующий массивы переменного размера. При создании память выделяется с запасом(capacity) для последующего роста.
  
* Сложности операций в std::vector
`Поиск: O(N), Удаление: O(M+K), где M - количество удалённых, K - количество сдвинутых из-за удаления , Добавление в середину: O(N), Добавление в конец: О(1) амортизированное, Сортировка: O(N * log(N)) - если использовать std::sort, Получение i-того элемента: О(1)`
Амортизированная сложность = иногда оно будет требовать больше (в нашем случае О(n)), но такие случаи редки достаточно, чтобы считать амортизированное значение верным.
* Пример работы с std::vector(1 Variant)
```bash
vector<int> a = {1,2,3};  // C++
a.at(1) = 5; // 5 2 3
vector<int> ap;
ap.reserve(3); // 0 0 0
ap.push_back(5); // 0 0 5
ap. pop_back(); // 0 0 
ap.insert(ap.end,4); // 0 0 4
```
* Пример работы с std::vector(2 Variant)
```bash
    // задача для детсадовцев - прочитать размер, прочитать массив, отсортировать по убыванию
    size_t N = 0;
	vector<int> vec;
	cin >> N;
	vec.resize(N);
	for (size_t i = 0; i < N; ++i) {
		cin >> vec[i];
	}

	sort(
	    vec.begin(), 
	    vec.end(), 
	    [](int i, int j) { return i < j; }
	);                                      
	for (size_t i = 0; i < N; ++i) {
		cout << vec[i] << endl;
	}
```
* Метод size(!)
> for(i =0, i < vector.size(),i++)
* Метод front and back
> Для просмотра 1 и N ячейки.
* Особенности std::vector<bool>
> Он сливает векторные элементы таким образом , что каждый из них занимает 1 бит, а не 1 байт.
  
### Вопрос №6 (Парадигмы ООП. Полиморфизм(статический, динамический). Инкапсуляция. Наследование. Примеры)
Полиморфизм - возможность одни и те же методы могут быть определены по-разному в классе-родителе и в классе-наследнике?
Наследование - возможность класса-наследника повторно использовать код (методы и поля) класса-родителя
Инкапсуляция - возможность разместить все данные и методы, логически связанные с данным классом внутри него и рассматривать объект этого класса как единое целое, а не взаимодействие множества разрозненных переменных. Также инкапсуляция - это сокрытие
* Полиморфизм статический с примером.
> Примером статического полиморфизма может служит судьба функции getRoots в примере наследования ниже.
* Полиморфизм динамический с примером.
Указатель на объект класса-родителя может указывать на объект класса-наследника. Пример:
```bash
class bin_operation {                           // класс-родитель
public:
	virtual int operator()(int, int) = 0;       // подробнее про функторы можно почитать в вопросе 12.4
};

class sum : public bin_operation {              // первый наследник
public:
	int operator()(int a, int b) {
		return a + b;
	}
};

class mult : public bin_operation {             // второй наследник
public:
	int operator()(int a, int b) {
		return a * b;
	}
};


int main() {
	vector<bin_operation*> operations{ new sum, new mult };  // кладём детей в указатели на родителей
	for (auto* o : operations) {
		cout << (*o)(2, 5) << endl;                          // каждый наследник по-своему выполняет код
	}
}
```
* Инкапсуляция с примером.
Я решил придумать пример в лице комплексного числа с простейшими арифметическими операциям
```bash
struct Complex {
	double a;
	double b;
	Complex(double re = 0, double im = 0): a(re), b(im) {}
	Complex operator~() { return Complex(a, -b); }
	Complex operator+(Complex z) { return Complex(a + z.a, b + z.b); }
	Complex operator*(Complex z) { return Complex(a * z.a - b * z.b, a * z.b + b * z.a); }
	double abs() { return a * a + b * b; }
	Complex operator/(double d) { return Complex(a / d, b / d); }
	Complex operator/(Complex z) { return (*this) * ~z / z.abs(); }
};
```
* Наследование с примером.
Простой кусок кода. Два класса, отец решает квадратное уравнение, а сын на основании этого решает биквадратное уравнение.
```bash
struct quadraticExpression{
	double a;
	double b;
	double c;
	quadraticExpression(double a1, double b1, double c1){
		a = a1;
		b = b1;
		c = c1;
	}
	double D() {
		return b * b - 4 * a * c;
	}
	virtual vector<optional<double>> getRoots() {       // про optional можно почитать в вопросе 11.1
		if (a == 0)
			return {-c/b};
		double d = D();
		if (d < 0)
			return {nullopt, nullopt};
		d = sqrt(d) / (2 * a);
		double _b = -b / (2 * a);
		return { _b + d, _b - d };
	}
};

struct biquadraticExpression : quadraticExpression {
	biquadraticExpression(double a1, double b1, double c1) : quadraticExpression(a1,b1,c1) {}
	vector<optional<double>> getRoots() {
		vector<optional<double>> roots = quadraticExpression::getRoots();
		vector<optional<double>> roots1;
		if (roots[0] == nullopt) {
			roots.push_back(nullopt);
			roots.push_back(nullopt);
			return roots;
		}
		for (auto item : roots) {             //auto и range-based loop - это вопросы 9.1 и 9.3
			if (item < 0) {
				roots1.push_back(nullopt);
				roots1.push_back(nullopt);
			} else {
				roots1.push_back(sqrt(item.value()));
				roots1.push_back(-sqrt(item.value()));
			}
		}
		return roots1;
	}
};
```
### Вопрос №7 (Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры)
* Шаблоны С++
Позволяет делать независимые от типа функции и классы.
Т.е. задать некоторое множество классов.
```bash
template <typename T, typename D>     // шаблон, требующий два типа - T и D
struct PointerWrapper
{
    T* pointer;
    
    virtual ~PointerWrapper() {   // напоминаю, это деструктор
        D{}();      // создаёт объект класса D и вызывает его. 
        // Если D - не функтор, то прога не соберётся
        // Почитать про функторы можно в вопросе 12.4
    }
};
```
Ключевые слова typename и class взаимозаменяемы в шапке шаблона.
Кроме класса в шаблон можно передавать вообще что угодно, даже числа (если они константы или могут быть расчитаны на этапе компиляции - смотри вопрос 9). Числами можно инициализировать, например, размеры константных массивов (array, bitset - хорошие примеры, но в нашем файле их нет). Пример этого смотри в вопросе 9 (пример2).
* Шаблоны С++: Инстанцирование
Инстанцирование - забив шаблонных параметров.
Результат инстанцирования - это класс.
```bash
using VectorOfString = std::vector<std::string>;
```
* Спецификация шаблонов
Спецификация - это задание более одного тела функции или класса для определенных параметров в шаблоне. То есть шаблон говорит: "вот толпа классов и все они одинаковые", а спецификация - это когда он добавляет: ", но вот ты будешь отличаться от них"
```bash
template <typename T, typename D>
struct PointerWrapper<void>     // спецификация для шаблона из примера в 7.1: если у нас T=void, то деструктор обычный, без приколов
{
    T* pointer;
    
    virtual ~PointerWrapper() = default;   // подробнее про default - вопрос 10.3
};
```
Нормальный пример: std::vector<bool> - это спецификация шаблона std::vector
* Шаблоны С++: Примеры
> Примеры внутри вопросов
### Вопрос №8 (Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы входа, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры)
Определение Итератора.
> Итератор — интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним.В простейшем случае итератором в низкоуровневых языках является указатель.Использование итераторов в обобщённом программировании позволяет реализовать универсальные алгоритмы работы с контейнерами.
* Назначение итератора
> Главное предназначение итераторов заключается в предоставлении возможности пользователю обращаться к любому элементу контейнера при сокрытии внутренней структуры контейнера от пользователя. Это позволяет контейнеру хранить элементы любым способом при допустимости работы пользователя с ним как с простой последовательностью или списком
* Преимущества итератора
По сравнению с индексацией итераторы имеют ряд преимуществ:
> Индексация подходит не для всех типов данных (например std::list)
	
> Итераторы предоставляют возможность последовательного перебора любых структур данных, поэтому делают код более читаемым, удобным для повторного использования и менее чувствительным к изменениям структур данных.

> Итераторы могут предоставлять дополнительные возможности при навигации по элементам. Например, проверку отсутствия пропусков элементов или защиту от повторного перебора одного и того же элемента.

> Некоторые контейнеры могут предоставлять возможность модифицировать свои объекты без влияния на сам итератор. Например, после того, как итератор уже «прошёл» первый элемент, можно вставить дополнительные элементы в начало контейнера без каких-либо нежелательных последствий. При использовании индексации это проблематично из-за смены номеров индексов.

* Итераторы ввода (InputIterator).
Итератор ввода – самый слабый из всех итераторов.
	* Что умеет:
	Сравнение (==/!=) - Итераторы будут равны, только если они указывают на одну и ту же позицию.
	Разыменовывание с помощью * или -> - При разыменовывании получаем rvalue
	Увеличиваемый - Можно ++ (произойдет переход на следующую позицию)
	Swap - Значения, на которые указывает итератор можно свапать
	* Что не умеет:
	Присвоение - Нельзя ничего присвоить местоположения, на которое указывает итератор (можно только получить доступ к ним)
	Уменьшение - Нельзя --
	Использование несколько раз - Один раз прошли и больше нельзя
	Другие операторы сравнения - Нельзя, например, <=
	Арифметические операторы - Нельзя it+2 (it-3) (можно std::next)
	*Зачем он нужен? 
	*Удобно использовать с алгоритмами, в которых мы можем перейти ко всем местоположениям не более одного раза.
	*Где используется? std::istream.
	
* Итераторы вывода.
Полная противоположность InputIterator.
	* Что умеет:
	Разыменовывание с помощью * или -> - При разыменовывании получаем lvalue
	Увеличиваемый - Можно ++ (произойдет переход на следующий элемент последовательности)
	Swap - Значения, на которые указывает итератор можно свапать
	* Что не умеет:
	Доступ - Нельзя получить доступ к выходным итераторам (выходной итератор может изменять только тот элемент, на который он 		указывает, будучи использованным в качестве цели для назначения)
	Уменьшение - Нельзя --
	Использование несколько раз - Один раз прошли и больше нельзя
	Сравнение - Нельзя никакие операторы сравнения
	Арифметические операторы - Нельзя it+2 (it-3) (можно std::next)
	*Зачем он нужен?
	Удобно использовать с алгоритмами, в которых мы можем перейти ко всем местоположениям не более одного раза.
	*Где используется? std::ostream.
	
* Прямой итератор.
	* Что умеет?
	Сравнение (==/!=)
	Разыменовывание с помощью * или -> - Может быть разыменован и как rvalue, и как lvalue
	Инкремент
	Swap
	* Что не умеет?
	Уменьшение
	Другие операторы сравнения
	Арифметические операторы
	Оператор []
	*Зачем он нужен? Удобен в многопроходных алгоритмах с одним напралением
	*Где используется? 
	std::forward_list
	std::unordered_set
	std::unordered_multiset
	std::unordered_map
	std::unordered_multimap
* Двунаправленные итераторы.
Итераторы, позволяющие двигаться как в прямом, так и в обратном направлении
	* Что умеет?
	Сравнение (==/!=)
	Разыменовывание с помощью * или -> - Может быть разыменован и как rvalue, и как lvalue
	Инкремент (если надо больше, используем std::next)
	Декремент (если надо больше, используем std::prev)
	Swap
	* Что не умеет?
	Другие операторы сравнения
	Арифметические операторы
	Оператор []
	*Зачем он нужен? Удобно использовать в многопроходных алгоритмах, где ходить нужно в обе стороны.
	*Где используется?
	std::list
	std::set
	std::multiset
	std::map
	std::multimap
	
* Итераторы прямого доступа.	
Таких не существует, но есть итераторы со случайным доступом (RandomAccessIterator). Будем про них.
Самые сильные в иерархии итераторов.
	* Что умеют?
	Сравнение (все виды)
	Разыменовывание с помощью * или -> - Может быть разыменован и как rvalue, и как lvalue
	Инкремент
	Декремент
	Арифметические операторы
	Оператор []
	Swap
	* Что не умеют?
	Всё могут.
	*Зачем они нужны? Удобно использовать для доступа по многу раз к элементам в любом порядке.
	*Где используются?
	std::vector
	std::deque
	std::array
	std::string
	std::string_view
	
* Примеры итераторов.
```bash
int main()
{
    std::forward_list<int> fl = { 0, 1, 2, 3 };     // про списки инициализации смотри вопрос 10.2, про list смотри вопрос 1
    auto begin = fl.begin();        // под auto скрыт std::forward_list<int>::iterator (подробнее - 9.1)
    ++begin;    // просто так шагнули вперёд
    auto end = fl.end();
    std::for_each(      // цикл for_each замечательно подходит для работы с итераторами
        begin, 
        end, 
        [](decltype(*(begin)) r) { std::cout << r << std::endl; }  // про лямбда-функции смотри вопрос 12.3
    ); // Вывод контейнера
}
// В консоли
// 1
// 2
// 3
```
### Вопрос №9 (Современный С++: auto,decltype, range base bool,nullptr,constexpr,enum class, if constexpr.)
* Auto
> auto - это ключевое слово для обозначения типа (как int, double, bool...), которое используется, чтобы сказать компилятору определять тип переменной по её инициализации. Соответственно, если инициализации нет (в момент объявления переменной мы ничего не присваиваем ей), то компилятор ломает нам колени, и программа не собирается. 

Тупой пример:
```bash
 auto w = true;     //компудахтор сам догадается, что под auto скрывается bool
```
Пример пояснения.
```bash
int main() {
	unordered_map<int, string> food_for_month{     //map с едой в столовке на месяц по дням
		{1, "tvorog"},
		{2, "pechen"},
		{3, "kefir&pryanic"},
		{4, "kompot_is_riby"},
		{5, "paper_with_ketchup"}
		//... дальше лень
	};
	int today = 3;
	auto bludo = food_for_month.find(today);  //под auto скрывается unordered_map<int, string>::iterator - класс, объявленный в шаблонном классе
	cout << bludo->second;
}
```
